{
    "subject": "Domain Layer",
    "fact": "Domain layer includes Aggregate Root, Entity, Value Object, Domain Service, Repository Interface",
    "citations": "DDD: Domain Layer is the heart of business logic",
    "reason": "Domain layer expresses business concepts, all business rules are centralized here",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer Dependency",
    "fact": "Domain layer must not depend on Application, Infrastructure, or Presentation layers",
    "citations": "Layered Architecture: Domain is independent",
    "reason": "Keep Domain pure, avoid business logic being polluted by external technology",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer",
    "fact": "Application layer includes Use Case, Facade, Store, Guard, Application Service, Mapper, Token",
    "citations": "Clean Architecture: Application orchestrates domain, provides use case API",
    "reason": "Application layer coordinates Domain behavior and provides it to Presentation layer",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Dependency",
    "fact": "Application layer can depend on Domain and Shared layers, but not on Infrastructure or Presentation layers",
    "citations": "Clean Architecture: Application depends only on domain abstractions",
    "reason": "Maintain layer boundaries, Infrastructure details can only be injected via Repository implementation",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer",
    "fact": "Infrastructure layer includes Repository implementation, third-party service adapters, data access, DTO, Converters, Collections",
    "citations": "DDD: Infrastructure adapts external systems to domain contracts",
    "reason": "Infrastructure encapsulates technical details, Domain only sees interface, not implementation",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer Dependency",
    "fact": "Infrastructure layer can depend on Domain and Shared layers, but not on Application or Presentation layers",
    "citations": "Layered Architecture: Infrastructure is below Application, above external systems",
    "reason": "Keep Domain and Application layers independent, Infrastructure is just an Adapter",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer",
    "fact": "Presentation layer includes Component, Page, Layout, Feature, Shared UI Service, Route, Signal / State",
    "citations": "Clean Architecture: Presentation consumes Application facades and stores",
    "reason": "Presentation is only responsible for display and user interaction, not business logic",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Dependency",
    "fact": "Presentation layer can depend on Application and Shared layers, but not directly on Domain or Infrastructure",
    "citations": "Clean Architecture: Presentation only sees Application APIs",
    "reason": "Prevent UI layer from operating Repository or Domain directly, maintain boundaries",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer",
    "fact": "Shared layer includes Value Object, Enum, Error, Interface, common libraries or types",
    "citations": "Shared layer provides cross-layer reusable constructs",
    "reason": "Maintain layer independence, provide common types and error management for all layers",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Dependency",
    "fact": "Shared layer must not depend on Domain, Application, Infrastructure, or Presentation layers",
    "citations": "Shared layer must remain framework-agnostic and cross-layer stable",
    "reason": "Avoid circular dependencies, keep layers clear",
    "category": "Shared Layer"
  },
  {
    "subject": "Global Layer Dependency Rule",
    "fact": "Dependency direction must be one-way: Presentation → Application → Domain ← Infrastructure, Shared can be depended on by all layers",
    "citations": "Clean Architecture / DDD layered structure",
    "reason": "Ensure architectural stability, prevent cross-layer cycles or pollution",
    "category": "All Layers"
  },
  {
    "subject": "Fail-Fast Enforcement",
    "fact": "Any layer violating dependency rules or using APIs from the wrong layer, Copilot must immediately stop implementation and prompt for correction",
    "citations": "DDD + Clean Architecture principles",
    "reason": "Maintain project layer boundaries and architectural purity",
    "category": "All Layers"
  },
  {
    "subject": "Aggregate Invariants",
    "fact": "Each Aggregate Root must encapsulate its invariants, external code must not break state directly",
    "citations": "DDD: Aggregates enforce business invariants internally",
    "reason": "Prevent business logic from being misused or Entity state being modified directly",
    "category": "Domain Layer"
  },
  {
    "subject": "Entity Identity",
    "fact": "Each Entity must have a unique ID and the ID must be immutable",
    "citations": "DDD: Entity identity distinguishes objects, should be immutable",
    "reason": "Ensure the same Entity is unique and traceable throughout the system",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Events",
    "fact": "Domain can define events, but events only describe facts and do not perform side effects",
    "citations": "DDD: Domain events describe state changes, side effects handled by Application",
    "reason": "Keep Domain pure, side effects are handled by Application or Infrastructure",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Error Handling",
    "fact": "Domain layer errors should be wrapped using DomainError or ValidationError types",
    "citations": "DDD: Domain should control its own exception types",
    "reason": "Unify error types, avoid noise from Infrastructure or UI leaking in",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer No Public Setter",
    "fact": "Domain Entity properties must not provide public setters, modification must be via methods or Aggregate behavior",
    "citations": "DDD: enforce invariants via behavior, not direct mutation",
    "reason": "Prevent external code from breaking Aggregate state",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Naming",
    "fact": "Repository interface naming must end with Aggregate name + Repository, e.g., UserRepository",
    "citations": "DDD naming convention",
    "reason": "Maintain readability and consistency, quickly identify each Aggregate's storage interface",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Method Signature",
    "fact": "Repository must not pass raw data structures to Domain, all input/output must use Value Object or Entity",
    "citations": "DDD: Repository is domain contract",
    "reason": "Ensure Domain is not polluted by DTO / Database structures",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Use Case Isolation",
    "fact": "Each Use Case must be a separate class or function, encapsulating a single business operation",
    "citations": "Clean Architecture: Use Case represents one application service",
    "reason": "Clear responsibility boundaries, avoid mixing multiple business logic",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Side Effects",
    "fact": "Use Case or Application Service can perform side effects, but must do so via Repository / Service Adapter",
    "citations": "Clean Architecture: Application layer mediates between Domain and external system",
    "reason": "Domain layer remains pure, Infrastructure handles side effects",
    "category": "Application Layer"
  },
  {
    "subject": "Facade Read-only Exposure",
    "fact": "Facade can only expose state or Signals, must not provide methods to modify Repository directly",
    "citations": "DDD + Angular Signals: Presentation should not mutate domain directly",
    "reason": "Prevent UI layer from breaking Domain behavior",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Adapter Isolation",
    "fact": "All operations to external systems (DB, API, third-party services) must be encapsulated in Adapter / Repository implementation",
    "citations": "Clean Architecture: infrastructure adapts external services to domain contract",
    "reason": "Domain / Application must not depend on external systems directly",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer DTO",
    "fact": "Infrastructure can use DTO for data transfer, but must not leak into Domain layer",
    "citations": "Clean Architecture: DTOs are infrastructure detail",
    "reason": "Isolate data structures from Domain, maintain purity",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer UI State",
    "fact": "Presentation layer state can only be managed via Signals / Store, must not operate Repository or Domain directly",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "Maintain isolation between Presentation layer and Domain / Infrastructure",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Component Reuse",
    "fact": "Shared Components can be created, but must be pure UI and not contain business logic",
    "citations": "DDD / Angular Component Guidelines",
    "reason": "Prevent business logic from leaking into UI, maintain separation of concerns",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Value Objects",
    "fact": "Shared layer Value Object must be immutable, have private internal value, and provide equals method",
    "citations": "DDD: Value Objects encapsulate state and equality",
    "reason": "Maintain consistency and safety when sharing across layers",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Error",
    "fact": "Shared Layer Error types should only be used for Domain validation or cross-layer error passing, must not depend on Application or Infrastructure",
    "citations": "DDD: Shared Error is layer-independent",
    "reason": "Maintain layer isolation, prevent circular dependencies",
    "category": "Shared Layer"
  }
