# Architectural Boundary Enforcement Rules

## Layer Dependency Rules (Strict)

### Presentation Layer Restrictions
**FORBIDDEN IMPORTS** in `src/app/presentation/**`:
- ❌ `@domain/event-bus/event-bus.interface` (EventBus)
- ❌ `@domain/event-store/event-store.interface` (EventStore)
- ❌ Direct imports from `@domain/event/*` (DomainEvent)

**ALLOWED IMPORTS** in `src/app/presentation/**`:
- ✅ `@application/interfaces/module-event-bus.interface` (IModuleEventBus abstraction)
- ✅ `@application/*/facades/*` (Facades)
- ✅ `@application/*/stores/*` (Stores)
- ✅ `@application/*/use-cases/*` (Use Cases - for command dispatch only)

### Event Publishing Rules
**ONLY** `@application/events/use-cases/publish-event.use-case.ts` can call:
- `eventStore.append(event)` - MUST be called FIRST
- `eventBus.publish(event)` - MUST be called AFTER append

**Event Handlers** (in `@application/*/handlers/*.ts`) can:
- Call other Use Cases to create derived events with causality
- Update stores via store methods
- Subscribe to EventBus for reactive updates

**Presentation Modules** (in `@presentation/**`) can:
- Call Use Cases to dispatch commands
- Subscribe to IModuleEventBus for view-model projection
- ❌ CANNOT publish events directly
- ❌ CANNOT call eventBus.publish or eventStore.append

### Causality Propagation Rules
When creating derived events (event A triggers event B):
- `correlationId`: MUST be inherited from parent event
- `causationId`: MUST be set to `parent.eventId`
- Example: QCFailed → IssueCreated

### Event Store Immutability
- Events MUST be frozen (`Object.freeze`) on append
- Query methods MUST return defensive copies
- No delete or update methods allowed

## Verification Commands

```bash
# Check for forbidden EventBus/EventStore imports in presentation
grep -r "from.*event-bus.interface\|from.*event-store.interface" src/app/presentation --include="*.ts"

# Check for direct publish/append calls outside PublishEventUseCase
grep -rn "eventBus\.publish\|eventStore\.append" src/app --include="*.ts" | grep -v "publish-event.use-case.ts" | grep -v ".spec.ts"

# Verify all stores are in application layer
find src/app -name "*.store.ts" | grep -v "src/app/application"
```

## Automated CI Gate

### Run Locally
```bash
npm run architecture:gate
```

### GitHub Actions Workflow
Create `.github/workflows/architecture-gate.yml`:

```yaml
name: Architecture Gate

on:
  push:
    branches: ['**']
    paths:
      - 'src/**/*.ts'
      - 'comprehensive-audit.js'
  pull_request:
    branches: ['**']
    paths:
      - 'src/**/*.ts'
      - 'comprehensive-audit.js'

permissions:
  contents: read

concurrency:
  group: architecture-gate-${{ github.ref }}
  cancel-in-progress: true

jobs:
  architecture-gate:
    name: Enforce Architecture Boundaries
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run Architecture Gate
        run: npm run architecture:gate
        env:
          NODE_ENV: production
```

## Violation = Architecture Breach
Any violation of these rules is considered an architectural boundary breach and MUST be corrected immediately.
