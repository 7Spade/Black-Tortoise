# 系統運作流程 (System Workflow)

本專案採用 **State-First, Router-Second** 的架構原則，確保狀態的可預測性與單一信賴來源，所有狀態流轉皆嚴格遵守 Domain-Driven Design (DDD) 與 Angular 20+ Signals 架構。

## 核心原則 (Core Principles)

1.  **Application Boundary Only**: Auth 狀態只存在於 Application Layer (`AuthStore`)，是單一真實來源 (Single Source of Truth)。
2.  **Signal-Based**: 所有狀態讀取皆透過 Signals，禁止在 Guard 或 Component 中使用 RxJS 訂閱 (Zone-less requirement)。
3.  **No Side-Effects in Guards**: Router Guard (`AuthGuard`) 只負責讀取 Signal 狀態並決定 `true` (Pass) / `UrlTree` (Redirect)，絕不觸發 Side Effects (如 API 呼叫)。
4.  **Infrastructure Isolation**: `@angular/fire` 與 Firebase SDK 僅存在於 Infrastructure Layer (`Repositories`)，對 Application 與 Domain Layer 透明。

---

## 驗證流程 (Authentication Flow)

### 1. 應用程式啟動 (App Bootstrap)

*   **觸發點**: `app.config.ts` 中的 `APP_INITIALIZER`。
*   **動作**:
    1.  注入 `AuthStore`。
    2.  執行 `authStore.connect()`。
    3.  **Infrastructure**: `AuthRepositoryImpl` 開始訂閱 Firebase `authState` stream。
*   **初始狀態**: `AuthStore` 初始化為 `status: "unknown"`。

### 2. 路由守衛初次評估 (Router Guard Evaluation - Cold Start)

*   **情境**: 使用者透過網址直接進入受保護路徑 (e.g., `/workspace`)。
*   **執行**: `canActivateAuth` 執行。
*   **邏輯**:
    *   讀取 `authStore.status()`。
    *   **結果**: 狀態為 `"unknown"` -> **ALLOW (return true)**。
    *   **理由**: 應用程式尚未收到 Firebase 回應，不應假設使用者未登入而跳轉。應讓路由通過，由 UI 層處理 Splash/Loading 狀態。

### 3. 基礎設施回應 (Infrastructure Response)

*   **觸發點**: Firebase SDK 初始化完成，透過 `authState$` stream 發出第一個狀態。
*   **路徑 (Data Flow)**: `Firebase SDK` -> `AuthRepository` (Mapper) -> `AuthStore` (rxMethod) -> `patchState`。

#### 情境 A: 使用者未登入 (Anonymous)
1.  Firebase 發出 `null`。
2.  `AuthStore` 更新狀態: `user: null`, `status: "anonymous"`.
3.  **UI 反應**:
    *   若當前在受保護頁面 (e.g. `/workspace`)，該頁面內部的 Effect 或 UI 邏輯偵測到 `anonymous` (或者等待 Router 再次評估)。
    *   通常實作上，Router Guard 會在導航期間再次被觸發，或 UI 顯示 "需要登入" 的提示並導向 `/auth/login`。

#### 情境 B: 使用者已登入 (Authenticated)
1.  Firebase 發出 `User` 物件。
2.  `AuthRepository` 將其轉換為 Domain `User` Entity (包含 `UserId`, `Email` VOs)。
3.  `AuthStore` 更新狀態: `user: Entity`, `status: "authenticated"`.
4.  **UI 反應**: 顯示完整應用程式內容。

### 4. 使用者登入 (User Login Action)

1.  **View**: 使用者在 `LoginPage` 輸入憑證並點擊登入。
2.  **Component**: 呼叫 `authStore.login(email, password)`。
3.  **Store**: 設定 `loading: true`，呼叫 `AuthRepository.login()`。
4.  **Infrastructure**: 呼叫 `signInWithEmailAndPassword` (Firebase SDK)。
5.  **Side Effect**: 成功後**不手動設定** User 狀態。
6.  **Stream Loop**: Firebase SDK 內部狀態改變 -> 觸發 `authState$` stream -> 回到 **"步驟 3"** 自動更新 Store。
7.  **Result**: UI 透過 Signal 自動更新，無須手動處理跳轉或狀態同步。

---

## 狀態機定義 (State Machine)

| AuthStatus | 定義 | Guard (CanActivateAuth) 行為 | UI 行為 |
| :--- | :--- | :--- | :--- |
| **unknown** | 初始化中，尚未確認身分 | **ALLOW** (return true) | 顯示 Splash / App Shell Skeleton |
| **anonymous** | 已確認未登入 | **Redirect** -> `/auth/login` | 顯示登入頁面 |
| **authenticated**| 已確認登入 | **ALLOW** (return true) | 顯示 Workspace / Dashboard |

---

## 架構分層責任 (Layer Responsibilities)

*   **Presentation (UI)**:
    *   **Component**: `LoginPage`, `WorkspacePage`
    *   **責任**: 讀取 `AuthStore` signals (`isLoading`, `error`, `status`) 渲染畫面。僅呼叫 Store methods (`login`, `logout`)。不包含任何業務邏輯。
*   **Application**:
    *   **Store**: `AuthStore`
    *   **責任**: 持有 Auth 狀態，協調 Login/Logout 動作，透過 Stream 同步 Infrastructure 狀態。
    *   **Guard**: `canActivateAuth`
    *   **責任**: 基於 Store 狀態保護路由。
*   **Domain**:
    *   **Entity**: `User`
    *   **Interface**: `AuthRepository`
    *   **責任**: 定義 User 形狀與 Auth 行為契約，不依賴任何外部庫。
*   **Infrastructure**:
    *   **Repository**: `AuthRepositoryImpl`
    *   **責任**: 實作 AuthRepository，直接操作 `@angular/fire`，負責將 Firebase 類型轉換為 Domain 類型。


