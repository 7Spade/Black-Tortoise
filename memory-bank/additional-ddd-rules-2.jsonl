{
  "subject": "Presentation Effect Cleanup",
  "fact": "Effects in Components must be created with {allowSignalWrites: false} unless explicitly modifying Signals, not default configuration",
  "citations": "Angular Signals: Prevent circular dependencies and infinite loops",
  "reason": "Maintain predictable data flow, prevent runtime errors, enable debugging",
  "category": "Presentation Layer"
},
{
  "subject": "Signal Store Hydration",
  "fact": "Store initialization must load state via withHooks onInit, not in constructor or ngOnInit",
  "citations": "ngrx/signals: withHooks provides lifecycle management for signalStore",
  "reason": "Ensure proper initialization timing, support SSR, enable testing",
  "category": "Application Layer"
},
{
  "subject": "Repository Pagination",
  "fact": "Repository pagination must use Value Object (PageRequest/PageResult), not primitive numbers or tuples",
  "citations": "DDD: Pagination is domain concept, requires encapsulation",
  "reason": "Maintain type safety, enable validation, support evolution",
  "category": "Domain Layer"
},
{
  "subject": "Domain Event Ordering",
  "fact": "Aggregate Root must maintain ordered collection of unpublished Domain Events, cleared after publication",
  "citations": "DDD: Event ordering ensures consistent event processing",
  "reason": "Maintain causality, enable event sourcing, support debugging",
  "category": "Domain Layer"
},
{
  "subject": "Use Case Input Validation",
  "fact": "Use Case must validate input using Value Objects before Domain operation, not inside Domain Entity",
  "citations": "Clean Architecture: Application validates external input, Domain enforces business rules",
  "reason": "Separate concerns, enable different validation contexts, maintain boundaries",
  "category": "Application Layer"
},
{
  "subject": "Store Loading State",
  "fact": "Store must track loading/error states using Signal<RequestState<T>> pattern, not separate boolean flags",
  "citations": "ngrx/signals: Unified state pattern prevents impossible states",
  "reason": "Prevent race conditions, simplify UI logic, ensure consistency",
  "category": "Application Layer"
},
{
  "subject": "Facade Dependency Injection",
  "fact": "Facade must inject Use Cases via dependency injection, not instantiate directly or use static methods",
  "citations": "Clean Architecture + Angular: DI enables testing and flexibility",
  "reason": "Enable mocking, support multiple implementations, maintain loose coupling",
  "category": "Application Layer"
},
{
  "subject": "Repository Transaction Isolation",
  "fact": "Repository implementation must not manage transactions; transaction control belongs to Application Use Case or Unit of Work",
  "citations": "DDD: Repository provides persistence, not transaction management",
  "reason": "Enable cross-repository transactions, maintain single responsibility",
  "category": "Infrastructure Layer"
},
{
  "subject": "Signal Effect Dependencies",
  "fact": "Effect must explicitly list all Signal dependencies in effect block, not access Signals conditionally",
  "citations": "Angular Signals: Conditional Signal access breaks reactivity tracking",
  "reason": "Ensure proper reactivity, prevent stale state, enable optimization",
  "category": "Presentation Layer"
},
{
  "subject": "Domain Invariant Enforcement",
  "fact": "Aggregate Root must enforce invariants in all mutation methods, using guard clauses or throwing DomainError",
  "citations": "DDD: Invariants are business rules that must always hold true",
  "reason": "Prevent invalid state, maintain data integrity, centralize validation",
  "category": "Domain Layer"
},
{
  "subject": "Application DTO Mapping",
  "fact": "Application Mapper must not expose Domain Entities directly to Presentation; map to Presentation DTOs/ViewModels",
  "citations": "Clean Architecture: Presentation layer should not depend on Domain structures",
  "reason": "Enable independent UI evolution, maintain layer isolation, support multiple UIs",
  "category": "Application Layer"
},
{
  "subject": "Store Optimistic Updates",
  "fact": "Store optimistic updates must revert on error using patchState with previous snapshot, not manual state restoration",
  "citations": "ngrx/signals: State immutability enables automatic rollback",
  "reason": "Ensure consistency, simplify error handling, maintain audit trail",
  "category": "Application Layer"
}
