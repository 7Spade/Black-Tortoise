{
    "subject": "DTO & Converter Example File",
    "fact": "dto.ts and converter.ts convert external data formats to Domain Entity / VO, isolating external data formats",
    "citations": "Clean Architecture: DTOs are infrastructure concern",
    "reason": "Protect Domain layer purity and consistency",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Page Component Example File",
    "fact": "page.component.ts and page.routes.ts define pages and routes, layout.component.ts is optional, UI layer accesses Application only via Facade / Store",
    "citations": "Angular + Clean Architecture",
    "reason": "Maintain UI layer one-way dependency and unified structure",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Value Object Example File",
    "fact": "value-object.ts is immutable, has private internal value, provides equals method, and is shared across layers",
    "citations": "DDD: Value Object encapsulates equality and state",
    "reason": "Ensure cross-layer consistency and safety",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Error Example File",
    "fact": "error.ts is used for Domain validation or cross-layer error passing, must not depend on Application / Infrastructure / Presentation",
    "citations": "DDD + Clean Architecture",
    "reason": "Maintain layer isolation, prevent circular dependencies",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Layer Folders & Files",
    "fact": "Domain layer folders: entities, aggregates, value-objects, enums, errors, interfaces, repositories; each folder contains the minimal corresponding file, such as entities.ts, aggregate.ts, value-objects.ts, repository.interface.ts, enums.ts, errors.ts",
    "citations": "DDD: Domain encapsulates business logic and aggregates",
    "reason": "Maintain Domain layer integrity and traceability",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer File List",
    "fact": "entities/entities.ts, aggregates/aggregate.ts, value-objects/value-objects.ts, enums/enums.ts, errors/errors.ts, interfaces/identifiable.interface.ts, repositories/repository.interface.ts",
    "citations": "DDD standard folder structure",
    "reason": "Ensure Domain layer dependency direction and functional completeness",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Folders & Files",
    "fact": "Application layer folders: use-cases, facades, stores, guards, mappers, tokens, services; each folder contains the minimal file: use-case.ts, facade.ts, store.ts, guard.ts, mapper.ts, token.ts, service.ts",
    "citations": "Clean Architecture: Application orchestrates Domain operations",
    "reason": "Maintain Application layer single responsibility, Presentation accesses Domain via Facade / Store",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer File List",
    "fact": "use-cases/index.ts, facades/facade.ts, stores/store.ts, guards/guard.ts, mappers/mapper.ts, tokens/token.ts, services/service.ts",
    "citations": "Clean Architecture",
    "reason": "Maintain layer isolation and one-way dependency",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Folders & Files",
    "fact": "Infrastructure layer folders: repositories, dto, converters, adapters, collections; each folder contains the minimal file repository.impl.ts, dto.ts, converter.ts, adapter.ts, collections.ts",
    "citations": "DDD: Infrastructure implements domain contracts",
    "reason": "Encapsulate technical details, keep Domain pure",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer File List",
    "fact": "repositories/repository.impl.ts, dto/dto.ts, converters/converter.ts, adapters/adapter.ts, collections/collections.ts",
    "citations": "Clean Architecture",
    "reason": "Maintain Infrastructure and Domain interface connection, prevent Domain pollution",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Folders & Files",
    "fact": "Presentation layer folders: pages, layouts, features, shared/components, shared/services; each folder contains the minimal file page.component.ts, page.routes.ts, layout.component.ts, shared.component.ts, shared.service.ts",
    "citations": "Clean Architecture + Angular Signals",
    "reason": "Maintain UI layer one-way dependency on Application layer",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer File List",
    "fact": "pages/page.component.ts, pages/page.routes.ts, layouts/layout.component.ts, shared/components/shared.component.ts, shared/services/shared.service.ts",
    "citations": "Angular + Clean Architecture",
    "reason": "Unify Presentation layer structure for easier maintenance",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Folders & Files",
    "fact": "Shared layer folders: value-objects, enums, errors, interfaces; each folder contains the minimal file value-object.ts, enums.ts, errors.ts, interfaces.ts",
    "citations": "DDD: Shared Layer provides reusable constructs",
    "reason": "Maintain cross-layer shared resources, avoid circular dependencies",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer File List",
    "fact": "value-objects/value-object.ts, enums/enums.ts, errors/errors.ts, interfaces/interfaces.ts",
    "citations": "DDD + Clean Architecture",
    "reason": "Ensure Shared layer can be depended on by all layers but does not depend on any layer",
    "category": "Shared Layer"
  }
{"timestamp":"2026-01-21T21:33:00Z","type":"architecture","content":"Module Refactoring Complete: Implemented event-driven architecture for all workspace modules. Created 11 module files (overview, documents, tasks, daily, quality-control, acceptance, issues, members, permissions, audit, settings) under src/app/presentation/modules/. All modules communicate ONLY via WorkspaceEventBus - no direct injection of WorkspaceContextStore or WorkspaceRuntimeFactory. Event bus passed via @Input() from parent components. Created shared utilities: ModuleEventHelper for common event patterns, ModuleEventSubscriptions for subscription management, and BaseModule as optional base class. Updated domain/module/module.interface.ts to include all 11 module types. All modules use Angular signals for zone-less state management and OnPush change detection."}
{"timestamp":"2026-01-21T21:33:00Z","type":"pattern","content":"Event-Driven Module Pattern: Modules receive WorkspaceEventBus via @Input() or constructor, never inject. Use ModuleEventHelper.onWorkspaceSwitched(), onModuleActivated(), etc. for subscriptions. Publish events with ModuleEventHelper.publishModuleInitialized(), publishModuleDataChanged(). Manage subscriptions with ModuleEventSubscriptions.add() and unsubscribeAll() in ngOnDestroy. Events flow through handle-domain-event.use-case (central bridge). This ensures loose coupling and testability."}
{"timestamp":"2026-01-21T21:33:00Z","type":"files","content":"Created files: src/app/presentation/modules/shared/module-event-helper.ts (event subscription utilities), src/app/presentation/modules/shared/base-module.ts (base pattern), src/app/presentation/modules/shared/index.ts (exports), src/app/presentation/modules/overview.module.ts, documents.module.ts, tasks.module.ts, daily.module.ts, quality-control.module.ts, acceptance.module.ts, issues.module.ts, members.module.ts, permissions.module.ts, audit.module.ts, settings.module.ts, and README.md (comprehensive documentation)."}
{"timestamp":"2026-01-21T21:33:00Z","type":"domain","content":"Extended ModuleType union in domain/module/module.interface.ts to include: overview, documents, tasks, daily, quality-control, acceptance, issues, members, permissions, audit, calendar, settings. Updated STANDARD_MODULES record with metadata (name, description, icon, routePath, isDefault) for all module types. This establishes the complete module taxonomy for the workspace system."}
{"timestamp":"2026-01-21T21:33:00Z","type":"deprecation","content":"Legacy modules demo-dashboard.module.ts and demo-settings.module.ts contain deprecated patterns (inject WorkspaceContextStore, inject WorkspaceRuntimeFactory, access runtime factory to get event bus). These should not be used as templates. They are kept for backward compatibility but violate the event-driven architecture principles."}
