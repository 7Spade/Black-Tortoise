{
    "subject": "Presentation Layer Folder Structure",
    "fact": "Presentation layer folders must include at least: pages, layouts, features, shared/components, shared/services",
    "citations": "Clean Architecture: Presentation only consumes Application APIs",
    "reason": "Maintain UI layer consistency and one-way dependency on Application layer",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Folder Structure",
    "fact": "Shared layer folders must include at least: value-objects, enums, errors, interfaces",
    "citations": "DDD: Shared Layer provides reusable domain constructs",
    "reason": "Maintain cross-layer sharing, avoid circular dependencies",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Aggregate File Example",
    "fact": "Each Aggregate Root file aggregate.ts must encapsulate Entities and Value Objects, provide behavior methods, and not expose property setters",
    "citations": "DDD: Aggregate Root enforces invariants",
    "reason": "Ensure Aggregate state consistency and business rule completeness",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Example",
    "fact": "Repository interface file repository.interface.ts must only depend on Domain Entity/VO, must not return DTO or Observable",
    "citations": "DDD: Repository is domain contract",
    "reason": "Keep Domain pure, not polluted by Infrastructure or Presentation technology",
    "category": "Domain Layer"
  },
  {
    "subject": "Use Case File Example",
    "fact": "Use Case file use-case.ts must encapsulate a single business logic and operate via Repository / Domain Service, not directly operate Infrastructure",
    "citations": "Clean Architecture: Use Case orchestrates domain",
    "reason": "Maintain single responsibility principle and layer boundaries",
    "category": "Application Layer"
  },
  {
    "subject": "Facade File Example",
    "fact": "Facade file facade.ts must expose Signals or Store, direct Repository operation is forbidden",
    "citations": "DDD + Angular Signals: UI must not mutate domain directly",
    "reason": "Maintain one-way data flow and Presentation layer purity",
    "category": "Application Layer"
  },
  {
    "subject": "Store File Example",
    "fact": "Store file store.ts must manage Signals state and only allow updates via Facade / Use Case",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "Maintain state consistency and one-way data flow",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Repository File Example",
    "fact": "Infrastructure repository.impl.ts file must implement the corresponding Domain Repository interface and encapsulate data access technology",
    "citations": "DDD: Infrastructure implements domain contracts",
    "reason": "Maintain Domain purity and dependency inversion principle",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "DTO & Converter File Example",
    "fact": "Infrastructure dto.ts and converter.ts files must convert external data structures into Domain Entity / VO",
    "citations": "Clean Architecture: DTO is infrastructure concern",
    "reason": "Isolate external data formats, protect Domain purity",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Page File Example",
    "fact": "Each page must have page.component.ts, page.routes.ts, and configure corresponding layout.component.ts (if needed)",
    "citations": "Angular + Clean Architecture",
    "reason": "Maintain UI layer consistency, easy to maintain and test",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Value Object File Example",
    "fact": "Shared value-object.ts must be immutable, have private internal value, and provide equals method",
    "citations": "DDD: Value Object encapsulates equality and state",
    "reason": "Maintain consistency and safety when sharing across layers",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Error File Example",
    "fact": "Shared error.ts must be used for Domain validation or cross-layer error passing, must not depend on Application / Infrastructure",
    "citations": "DDD + Clean Architecture",
    "reason": "Maintain layer isolation, prevent circular dependencies",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Layer Folder & File Template",
    "fact": "Domain layer folders include entities, aggregates, value-objects, enums, errors, interfaces, repositories; core files include aggregate.ts, entities.ts, value-objects.ts, repository.interface.ts, enums.ts, errors.ts",
    "citations": "DDD: Domain encapsulates business logic, Aggregate Root enforces invariants",
    "reason": "Keep Domain pure, complete, and traceable",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer Dependencies",
    "fact": "Domain layer only depends on Shared layer's Value Objects, Enums, Errors, Interfaces, and does not depend on Application, Infrastructure, or Presentation",
    "citations": "DDD + Clean Architecture: Domain is core layer",
    "reason": "Maintain one-way dependency, prevent Domain layer pollution",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Folder & File Template",
    "fact": "Application layer folders include use-cases, facades, stores, guards, mappers, tokens, services; core files include use-case.ts, facade.ts, store.ts, mapper.ts, guard.ts, token.ts, service.ts",
    "citations": "Clean Architecture: Application orchestrates domain",
    "reason": "Maintain single responsibility principle, Presentation accesses Domain via Facade / Store",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Dependencies",
    "fact": "Application layer depends on Domain layer's Entities / Value Objects / Repositories Interface and Shared layer, but not on Infrastructure or Presentation",
    "citations": "Clean Architecture: Application mediates between Domain and Presentation",
    "reason": "Maintain layer isolation and one-way dependency",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Folder & File Template",
    "fact": "Infrastructure layer folders include repositories, dto, converters, adapters, collections; core files include repository.impl.ts, dto.ts, converter.ts, adapter.ts, collections.ts",
    "citations": "DDD: Infrastructure implements domain contracts and adapts external systems",
    "reason": "Encapsulate technical details, Domain only sees interface, not polluted",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer Dependencies",
    "fact": "Infrastructure layer depends on Domain layer Repository Interface / Value Objects / Entities and Shared layer, Presentation / Application layer must not be depended on by Infrastructure",
    "citations": "Clean Architecture: Infrastructure adapts external systems to domain contracts",
    "reason": "Maintain layer dependency inversion principle",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Folder & File Template",
    "fact": "Presentation layer folders include pages, layouts, features, shared/components, shared/services; core files include page.component.ts, page.routes.ts, layout.component.ts, shared.component.ts, shared.service.ts",
    "citations": "Clean Architecture + Angular: Presentation consumes Application APIs only",
    "reason": "Maintain one-way data flow, UI does not pollute Domain / Application",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Dependencies",
    "fact": "Presentation layer depends on Application layer's Facade / Store and Shared layer, does not directly depend on Domain / Infrastructure",
    "citations": "Clean Architecture: UI layer interacts only via Application layer",
    "reason": "Ensure one-way dependency and responsibility isolation",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Folder & File Template",
    "fact": "Shared layer folders include value-objects, enums, errors, interfaces; core files include value-object.ts, enums.ts, errors.ts, interfaces.ts",
    "citations": "DDD: Shared Layer provides reusable constructs across layers",
    "reason": "Maintain cross-layer shared resources and avoid circular dependencies",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Dependencies",
    "fact": "Shared layer must not depend on Domain / Application / Infrastructure / Presentation layers, but can be depended on by all layers",
    "citations": "DDD + Clean Architecture",
    "reason": "Ensure cross-layer sharing without causing circular dependencies",
    "category": "Shared Layer"
  },
  {
    "subject": "Aggregate Example File",
    "fact": "aggregate.ts encapsulates Entities / Value Objects, provides behavior methods, forbids public setter, ensures invariants",
    "citations": "DDD: Aggregate Root enforces business invariants",
    "reason": "Prevent external code from breaking Aggregate state",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Example File",
    "fact": "repository.interface.ts only depends on Domain Entity / VO, does not return DTO or Observable, defines CRUD / query methods",
    "citations": "DDD: Repository is domain contract",
    "reason": "Keep Domain layer pure, not polluted by technical details",
    "category": "Domain Layer"
  },
  {
    "subject": "Use Case Example File",
    "fact": "use-case.ts encapsulates a single business logic, operates via Repository / Domain Service, does not directly operate Infrastructure",
    "citations": "Clean Architecture: Use Case orchestrates Domain",
    "reason": "Maintain single responsibility and layer boundaries",
    "category": "Application Layer"
  },
  {
    "subject": "Facade Example File",
    "fact": "facade.ts exposes Signals / Store to Presentation, does not directly operate Repository",
    "citations": "DDD + Angular Signals: UI must not mutate Domain directly",
    "reason": "Maintain one-way data flow, Presentation does not pollute Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Store Example File",
    "fact": "store.ts manages Signals state, only allows updates via Facade / Use Case",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "Maintain state consistency and one-way data flow",
    "category": "Application Layer"
  },
  {
    "subject": "Repository Implementation Example",
    "fact": "repository.impl.ts implements the corresponding Domain Repository interface, encapsulates data access technology, provides CRUD and query methods",
    "citations": "DDD: Infrastructure implements Domain contracts",
    "reason": "Keep Domain pure, prevent Presentation / Application from directly depending on external systems",
    "category": "Infrastructure Layer"
  }
