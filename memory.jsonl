  {
    "subject": "Domain Repository",
    "fact": "Domain Repository interface 不得使用 Observable / RxJS / framework abstraction",
    "citations": "Domain Layer should only describe domain contracts; Repository must not expose implementation detail.",
    "reason": "Observable 等概念屬於 Infrastructure，Domain 只描述行為與 Aggregate 存取，不應依賴實作。",
    "category": "Domain Layer"
  },
  {
    "subject": "Aggregate Boundary",
    "fact": "每個 Aggregate Root 必須對應一個 Repository，Repository 不得跨 Aggregate",
    "citations": "DDD Principle: one Aggregate Root = one Repository",
    "reason": "保持一致性邊界，避免跨 Aggregate 的意外副作用。",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Method Naming",
    "fact": "Domain Repository 不能出現 getAll、getUsers、watch* 類 UI 導向 API",
    "citations": "Repository interface 只描述業務行為，不為 UI 或 Store 設計",
    "reason": "防止 Domain 層被 UI / Store 需求污染。",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Return Types",
    "fact": "Domain Repository 只能回傳 Promise 或同步值，禁止 Observable",
    "citations": "DDD: Domain should remain pure, asynchronous handling is for Application/Infrastructure",
    "reason": "保持 Domain 層獨立於非同步實作細節。",
    "category": "Domain Layer"
  },
  {
    "subject": "Value Object Usage",
    "fact": "Repository 與 Entity 的 ID 必須使用 Value Object，禁止 string / number 直接傳遞",
    "citations": "DDD: Value Objects encapsulate identity, enhance type safety",
    "reason": "保護 Domain 型別安全，統一 Aggregate 身份表示。",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Services",
    "fact": "Domain Services 只能依賴 Domain Repository interface，禁止使用 Infrastructure / UI",
    "citations": "DDD: Domain Service is pure domain logic",
    "reason": "避免 Domain Service 被實作細節污染。",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Dependency",
    "fact": "Application 層只能依賴 Domain 層，不可直接使用 Infrastructure 實作",
    "citations": "Layered Architecture: Application orchestrates Domain, does not know Infrastructure",
    "reason": "保持層級邊界清晰，防止 Application 層滲透 Infrastructure。",
    "category": "Application Layer"
  },
  {
    "subject": "Facade / Store",
    "fact": "Facade / Store 不可暴露 Repository API 或 Observable，僅提供 Signals 或純狀態",
    "citations": "Application Layer: provide state for Presentation only",
    "reason": "Presentation 不應直接操作 Repository，防止副作用洩漏。",
    "category": "Application Layer"
  },
  {
    "subject": "Guard",
    "fact": "Guard 僅能做純條件判斷，禁止 subscribe、navigation 或副作用",
    "citations": "Application Layer: Guards are pure, signals-only",
    "reason": "防止 Guard 變成流程控制或資料修改點，保持純粹。",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer",
    "fact": "Infrastructure 實作 Domain Repository，可使用 Observable / AngularFire / Firestore",
    "citations": "DDD: Infrastructure adapts persistence to Domain contract",
    "reason": "Infrastructure 層可以依賴框架，但不能污染 Domain。",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer",
    "fact": "Presentation 層不得 import Domain Repository 或 Infrastructure，僅使用 Facade / Store",
    "citations": "DDD + Layered Architecture: Presentation only sees Application layer",
    "reason": "保持層級邊界，防止 UI 滲透業務邏輯。",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer",
    "fact": "Shared 僅允許 base Value Objects / enums / error / interfaces，禁止依賴 Application / Infrastructure / Presentation",
    "citations": "Shared layer is framework-agnostic and cross-layer stable",
    "reason": "保持可重用性與層級獨立性。",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Repository Contract",
    "fact": "Domain Repository interface 只能使用 Promise 或同步值，不得依賴 Observable / RxJS / framework",
    "citations": "DDD: Repository is a domain contract, infrastructure-specific behavior must not leak",
    "reason": "保持 Domain 純粹，避免時間軸 / UI 概念污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Aggregate Boundary",
    "fact": "每個 Aggregate Root 必須有單獨 Repository，Repository 不可跨 Aggregate",
    "citations": "DDD Principle: one Aggregate Root = one Repository",
    "reason": "保持一致性邊界，防止跨 Aggregate 副作用",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Naming",
    "fact": "Domain Repository 不可使用 getAll / getUsers / watch* 之類的 UI 導向 API",
    "citations": "Repository is about domain behavior, not UI convenience",
    "reason": "避免 Domain 被 Presentation 或 Store 污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Value Object Enforcement",
    "fact": "Aggregate IDs 和 Owner 必須使用 Value Object，不得使用 string / number",
    "citations": "DDD: Value Objects encapsulate identity",
    "reason": "保持型別安全與 Domain 語義一致",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Service Dependency",
    "fact": "Domain Service 只能依賴 Domain Repository interface，禁止使用 Infrastructure / UI",
    "citations": "DDD: Domain Service is pure domain logic",
    "reason": "保持 Domain 純粹，不被實作細節污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Orchestration",
    "fact": "Application 層只能依賴 Domain 層，使用 Facade / Store / Guards 協調 Use Case",
    "citations": "Layered Architecture: Application orchestrates Domain",
    "reason": "保持層級清晰，防止 Infrastructure 或 UI 滲入",
    "category": "Application Layer"
  },
  {
    "subject": "Use Case Output",
    "fact": "Use Case 不得回傳 Observable，僅使用 Promise 或純資料結構",
    "citations": "DDD + Clean Architecture: Domain async handling stays in infrastructure",
    "reason": "Application 層負責轉換成 Signals / Store / Presentation 可用狀態",
    "category": "Application Layer"
  },
  {
    "subject": "Facade / Store Rules",
    "fact": "Facade / Store 不可暴露 Repository API 或 Observable，僅提供 Signals 或純狀態",
    "citations": "Application Layer provides state for Presentation only",
    "reason": "Presentation 不直接依賴 Repository，防止副作用洩漏",
    "category": "Application Layer"
  },
  {
    "subject": "Guard Purity",
    "fact": "Guard 僅能做同步或 signals-only 判斷，不可副作用、導航或 subscribe",
    "citations": "Application Layer: Guards are pure and signals-only",
    "reason": "防止 Guard 變成流程控制或資料修改點",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Implementation",
    "fact": "Infrastructure 可以使用 Observable / AngularFire / Firestore 等，但不可污染 Domain",
    "citations": "DDD: Infrastructure adapts persistence to Domain contract",
    "reason": "將實作細節封裝在 Infrastructure 層，Domain 保持純粹",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Rules",
    "fact": "Presentation 不可 import Domain Repository 或 Infrastructure，只能使用 Application Facade / Store",
    "citations": "DDD + Clean Architecture: Presentation only sees Application",
    "reason": "保持層級邊界，UI 不直接操作 Domain / Infrastructure",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Rules",
    "fact": "Shared 僅能包含 Value Objects / enums / error / interfaces，不可依賴 Application / Infrastructure / Presentation",
    "citations": "Shared layer must remain framework-agnostic and cross-layer stable",
    "reason": "保持可重用性與層級獨立性",
    "category": "Shared Layer"
  },
  {
    "subject": "Global Layer Enforcement",
    "fact": "任何層級不得跨界 import，不得讓 Infrastructure / UI API 滲入 Domain",
    "citations": "Layered Architecture / DDD",
    "reason": "維護清晰邊界，Fail-Fast 原則",
    "category": "All Layers"
  },
  {
    "subject": "Fail-Fast Behavior",
    "fact": "Copilot 發現 Domain 使用 Observable、getUsers、跨 Aggregate Repository 等行為時必須立即停止實作",
    "citations": "Domain pureness must be enforced",
    "reason": "防止不當依賴進入核心 Domain",
    "category": "All Layers"
  },
  {
    "subject": "Infrastructure Adapter Pattern",
    "fact": "任何 Infrastructure 對外提供即時資料，必須透過 Adapter，Domain 不直接暴露實時流",
    "citations": "Clean Architecture / DDD: Adapter isolates Infrastructure",
    "reason": "保持 Domain 與 Application 獨立",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Application to Presentation Mapping",
    "fact": "Application 必須負責將 Domain Entity 轉為 Presentation Signals 或 ViewModel",
    "citations": "Clean Architecture: Application mediates between Domain and Presentation",
    "reason": "防止 Presentation 直接依賴 Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Domain Layer",
    "fact": "Domain 層包含 Aggregate Root、Entity、Value Object、Domain Service、Repository Interface",
    "citations": "DDD: Domain Layer is the heart of business logic",
    "reason": "Domain 層表達業務概念，所有業務規則集中於此",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer Dependency",
    "fact": "Domain 層不可依賴 Application、Infrastructure 或 Presentation 層",
    "citations": "Layered Architecture: Domain is independent",
    "reason": "保持 Domain 純粹，避免業務邏輯被外部技術污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer",
    "fact": "Application 層包含 Use Case、Facade、Store、Guard、Application Service、Mapper、Token",
    "citations": "Clean Architecture: Application orchestrates domain, provides use case API",
    "reason": "Application 層協調 Domain 行為並提供給 Presentation 層使用",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Dependency",
    "fact": "Application 層可依賴 Domain 層、Shared 層，不可依賴 Infrastructure 或 Presentation 層",
    "citations": "Clean Architecture: Application depends only on domain abstractions",
    "reason": "維持層級邊界，Infrastructure 細節只能透過 Repository 實作被注入",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer",
    "fact": "Infrastructure 層包含 Repository 實作、第三方服務適配器、資料存取、DTO、Converters、Collections",
    "citations": "DDD: Infrastructure adapts external systems to domain contracts",
    "reason": "Infrastructure 封裝技術細節，Domain 只看到 interface，不看到實作",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer Dependency",
    "fact": "Infrastructure 層可以依賴 Domain 與 Shared 層，但不可依賴 Application 或 Presentation 層",
    "citations": "Layered Architecture: Infrastructure is below Application, above external systems",
    "reason": "保持 Domain 與 Application 層獨立，Infrastructure 只是 Adapter",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer",
    "fact": "Presentation 層包含 Component、Page、Layout、Feature、Shared UI Service、Route、Signal / State",
    "citations": "Clean Architecture: Presentation consumes Application facades and stores",
    "reason": "Presentation 只負責顯示與使用者互動，不實作業務邏輯",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Dependency",
    "fact": "Presentation 層可依賴 Application 與 Shared 層，不可直接依賴 Domain 或 Infrastructure",
    "citations": "Clean Architecture: Presentation only sees Application APIs",
    "reason": "防止 UI 層直接操作 Repository 或 Domain，維護邊界",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer",
    "fact": "Shared 層包含 Value Object、Enum、Error、Interface、常用函式庫或型別",
    "citations": "Shared layer provides cross-layer reusable constructs",
    "reason": "維持層級獨立性，提供各層通用型別與錯誤管理",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Dependency",
    "fact": "Shared 層不可依賴 Domain、Application、Infrastructure 或 Presentation 層",
    "citations": "Shared layer must remain framework-agnostic and cross-layer stable",
    "reason": "避免形成循環依賴，保持層級清晰",
    "category": "Shared Layer"
  },
  {
    "subject": "Global Layer Dependency Rule",
    "fact": "依賴方向必須單向: Presentation → Application → Domain ← Infrastructure, Shared 可被所有層依賴",
    "citations": "Clean Architecture / DDD layered structure",
    "reason": "確保架構穩定，防止跨層循環或污染",
    "category": "All Layers"
  },
  {
    "subject": "Fail-Fast Enforcement",
    "fact": "任何層級違反依賴規則或使用不該層的 API，Copilot 必須立即停止實作並提示修正",
    "citations": "DDD + Clean Architecture principles",
    "reason": "維護專案層級邊界與架構純粹性",
    "category": "All Layers"
  },
  {
    "subject": "Aggregate Invariants",
    "fact": "每個 Aggregate Root 必須封裝其不變條件 (invariants)，不能讓外部直接破壞狀態",
    "citations": "DDD: Aggregates enforce business invariants internally",
    "reason": "防止業務邏輯被外部誤用或直接修改 Entity 狀態",
    "category": "Domain Layer"
  },
  {
    "subject": "Entity Identity",
    "fact": "每個 Entity 必須有唯一 ID 且 ID 不可變動",
    "citations": "DDD: Entity identity distinguishes objects, should be immutable",
    "reason": "確保相同 Entity 在整個系統中唯一且可追蹤",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Events",
    "fact": "Domain 可以定義事件，但事件只描述事實，不執行副作用",
    "citations": "DDD: Domain events describe state changes, side effects handled by Application",
    "reason": "保持 Domain 純粹，副作用由 Application 或 Infrastructure 處理",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Error Handling",
    "fact": "Domain 層錯誤應使用 DomainError 或 ValidationError 類型封裝",
    "citations": "DDD: Domain should control its own exception types",
    "reason": "統一錯誤類型，避免 Infrastructure 或 UI 雜訊滲入",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer No Public Setter",
    "fact": "Domain Entity 屬性不得提供 public setter，必須透過方法或 Aggregate 行為修改",
    "citations": "DDD: enforce invariants via behavior, not direct mutation",
    "reason": "防止外部破壞 Aggregate 狀態",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Naming",
    "fact": "Repository interface 命名必須以 Aggregate 名稱 + Repository 結尾，例如 UserRepository",
    "citations": "DDD naming convention",
    "reason": "保持可讀性和一致性，快速辨識每個 Aggregate 的儲存接口",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Method Signature",
    "fact": "Repository 不得傳遞原始資料結構給 Domain，所有輸入輸出必須使用 Value Object 或 Entity",
    "citations": "DDD: Repository is domain contract",
    "reason": "確保 Domain 不被 DTO / Database 結構污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Use Case Isolation",
    "fact": "每個 Use Case 必須是一個獨立 class 或 function，封裝單一業務操作",
    "citations": "Clean Architecture: Use Case represents one application service",
    "reason": "清晰責任邊界，避免混合多個業務邏輯",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Side Effects",
    "fact": "Use Case 或 Application Service 可以執行副作用，但必須透過 Repository / Service Adapter",
    "citations": "Clean Architecture: Application layer mediates between Domain and external system",
    "reason": "Domain 層保持純粹，Infrastructure 處理副作用",
    "category": "Application Layer"
  },
  {
    "subject": "Facade Read-only Exposure",
    "fact": "Facade 只能暴露狀態或 Signals，禁止提供直接修改 Repository 的方法",
    "citations": "DDD + Angular Signals: Presentation should not mutate domain directly",
    "reason": "避免 UI 層破壞 Domain 行為",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Adapter Isolation",
    "fact": "所有對外部系統（DB、API、第三方服務）的操作必須封裝在 Adapter / Repository 實作中",
    "citations": "Clean Architecture: infrastructure adapts external services to domain contract",
    "reason": "Domain / Application 不直接依賴外部系統",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer DTO",
    "fact": "Infrastructure 可使用 DTO 作為資料傳輸，但不得流入 Domain 層",
    "citations": "Clean Architecture: DTOs are infrastructure detail",
    "reason": "隔離資料結構與 Domain，維護純粹性",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer UI State",
    "fact": "Presentation 層狀態只能透過 Signals / Store 管理，禁止直接操作 Repository 或 Domain",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "維護 Presentation 層與 Domain / Infrastructure 的隔離",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Component Reuse",
    "fact": "可建立 Shared Component，但必須純 UI，不得包含業務邏輯",
    "citations": "DDD / Angular Component Guidelines",
    "reason": "避免業務邏輯洩漏到 UI，保持責任分離",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Value Objects",
    "fact": "Shared 層 Value Object 必須不可變（immutable）、私有內部值、提供 equals 方法",
    "citations": "DDD: Value Objects encapsulate state and equality",
    "reason": "跨層共享時保持一致性和安全",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Error",
    "fact": "Shared Layer Error 類型應只用於 Domain 驗證或跨層錯誤傳遞，禁止依賴 Application 或 Infrastructure",
    "citations": "DDD: Shared Error is layer-independent",
    "reason": "維持層級隔離，避免循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Cross-layer Dependency Rule",
    "fact": "所有層依賴方向必須單向：Presentation → Application → Domain ← Infrastructure，Shared 可被所有層依賴",
    "citations": "Clean Architecture / DDD",
    "reason": "防止循環依賴，保持架構穩定",
    "category": "All Layers"
  },
  {
    "subject": "Layered Contract Enforcement",
    "fact": "每層必須明確 contract，任何跨層直接操作或破壞 contract 都算違規",
    "citations": "DDD + Clean Architecture principles",
    "reason": "確保層級邊界、聚合一致性和系統可維護性",
    "category": "All Layers"
  },
  {
    "subject": "Signals-only Presentation",
    "fact": "Presentation 層所有可變狀態只能透過 Signals 或 State Store 管理，不得在 Component 中直接改 Domain Entity",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "維持單向資料流，避免副作用洩漏",
    "category": "Presentation Layer"
  },
  {
    "subject": "Infrastructure Error Mapping",
    "fact": "Infrastructure 捕獲錯誤後必須映射為 Domain Error 或 Application Error，再回傳 Application",
    "citations": "Clean Architecture: Infrastructure must translate technical errors",
    "reason": "保持層級隔離，避免漏入技術實作細節",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Domain Layer Structure",
    "fact": "Domain 層必須包含 Entities、Aggregates、Value Objects、Domain Services、Enums、Errors、Interfaces、Repositories Interface",
    "citations": "DDD: Domain encapsulates business logic and aggregates",
    "reason": "確保業務邏輯完整，Aggregate / Entity / VO / Service 不會缺失",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Structure",
    "fact": "Application 層必須包含 Use Cases、Facades、Stores、Guards、Mappers、Tokens、Services",
    "citations": "Clean Architecture: Application orchestrates domain and exposes API to Presentation",
    "reason": "維持層級邊界，Presentation 只能透過 Facade 或 Store 存取業務",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Structure",
    "fact": "Infrastructure 層必須包含 Repository 實作、Adapters、DTO、Converters、Collections",
    "citations": "DDD: Infrastructure implements domain contracts and adapts external systems",
    "reason": "封裝技術細節，Domain 只看到 interface，不被污染",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Structure",
    "fact": "Presentation 層必須包含 Pages、Layouts、Features、Shared Components、Shared Services、Routes",
    "citations": "Clean Architecture: Presentation consumes Application APIs only",
    "reason": "UI 層不直接操作 Domain 或 Infrastructure，保持單向依賴",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Structure",
    "fact": "Shared 層必須包含 Value Objects、Enums、Error 類別、Interfaces、常用函式庫或型別",
    "citations": "Shared Layer provides cross-layer reusable constructs",
    "reason": "保持可重用性與層級獨立性，避免循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Entities Required",
    "fact": "每個 Aggregate 必須至少有一個 Entity，Entity 必須有唯一 ID 和不可變 Value Objects 作為屬性",
    "citations": "DDD: Entities are identified by their identity and encapsulate state",
    "reason": "保證 Aggregate 狀態一致性與追蹤性",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Aggregate Required",
    "fact": "每個 Aggregate Root 必須封裝其所有相關 Entities 和 Value Objects，並提供行為方法操作",
    "citations": "DDD: Aggregate Root enforces invariants and encapsulates internal entities",
    "reason": "防止外部直接修改 Aggregate 內部狀態",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Required",
    "fact": "每個 Aggregate Root 必須有對應 Repository interface，定義 CRUD 或查詢方法，回傳 Entity 或 Promise，不可回傳 Observable 或 DTO",
    "citations": "DDD: Repository is domain contract",
    "reason": "保持 Domain 純粹，避免被實作細節污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Use Case Required",
    "fact": "每個業務操作必須由獨立 Use Case class 或 function 實作，封裝單一功能",
    "citations": "Clean Architecture: Use Case represents one application service",
    "reason": "保持 Application 層責任單一且可測試",
    "category": "Application Layer"
  },
  {
    "subject": "Facade Required",
    "fact": "每個 Presentation 功能或頁面必須透過 Facade 提供 Signals 或 State，禁止直接操作 Repository",
    "citations": "DDD + Angular Signals: Presentation must not mutate domain directly",
    "reason": "保持單向資料流，Presentation 不污染 Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Store Required",
    "fact": "Store 必須管理 Signals 狀態，並僅透過 Facade 或 Use Case 更新，不可直接被 Component 修改",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "維持 Presentation 層狀態一致性和單向資料流",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Repository Implementation",
    "fact": "每個 Repository interface 必須有對應 Infrastructure 實作，用於存取 DB / API / Firebase 等",
    "citations": "DDD: Infrastructure implements domain contracts",
    "reason": "Domain interface 與 Infrastructure 實作分離，保持依賴倒置原則",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "DTO & Converter Required",
    "fact": "Infrastructure 若使用外部資料結構，必須定義 DTO 與對應 Converter，不可將原始資料直接流入 Domain",
    "citations": "Clean Architecture: DTO is infrastructure concern",
    "reason": "隔離資料格式，保護 Domain 層純粹性",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Page Structure",
    "fact": "每個頁面必須有對應 Page Component、Route 定義及 Layout 配置，確保 UI 層統一",
    "citations": "Angular + Clean Architecture",
    "reason": "維持 UI 層結構一致，方便維護與測試",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Value Object Standards",
    "fact": "Shared 層 Value Object 必須不可變、私有內部值、提供 equals 方法與型別安全操作",
    "citations": "DDD: Value Object encapsulates equality and state",
    "reason": "跨層共享時保持一致性與安全",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Error Standards",
    "fact": "Shared 層錯誤類型必須用於 Domain 驗證或跨層錯誤傳遞，不可依賴 Application 或 Infrastructure",
    "citations": "DDD + Clean Architecture",
    "reason": "保持層級隔離，防止循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Layer Minimal Files",
    "fact": "Domain 層每個 Aggregate Root 必須至少有 entities.ts、value-objects.ts、repository.interface.ts、aggregate.ts（若適用）、enums.ts、errors.ts",
    "citations": "DDD: Aggregate Root encapsulates state and behavior, Value Objects are immutable",
    "reason": "保證 Domain 層完整、可追蹤、遵守 DDD 原則",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Minimal Files",
    "fact": "Application 層每個功能至少有 use-cases/index.ts、use-case.ts、facade.ts、store.ts、guard.ts（若需）、mapper.ts、tokens.ts",
    "citations": "Clean Architecture: Application orchestrates domain operations and exposes APIs to Presentation",
    "reason": "保持 Application 層邏輯單一且可測試，Presentation 不直接操作 Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Minimal Files",
    "fact": "Infrastructure 層每個 Repository interface 必須有對應 repository.impl.ts、dto.ts、converter.ts、adapter.ts（若需）、collections.ts（若需）",
    "citations": "DDD: Infrastructure implements domain contracts and adapts external systems",
    "reason": "封裝技術細節，Domain 只看到 interface，不受污染",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Minimal Files",
    "fact": "Presentation 層每個頁面至少有 page.component.ts、page.routes.ts、layout.component.ts（若適用）、shared/components/*.ts、shared/services/*.ts",
    "citations": "Clean Architecture + Angular: Presentation consumes Application APIs via Facades and Stores",
    "reason": "維持 UI 層統一、單向資料流，避免破壞 Domain 或 Application 層",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Minimal Files",
    "fact": "Shared 層至少包含 value-objects/index.ts、enums/index.ts、errors/index.ts、interfaces/index.ts",
    "citations": "DDD: Shared Layer provides cross-layer reusable constructs",
    "reason": "保持可重用性與層級獨立性，避免循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Layer Folder Structure",
    "fact": "Domain 層資料夾至少包含: entities、aggregates、value-objects、enums、errors、interfaces、repositories",
    "citations": "DDD: Domain organizes concepts per aggregate",
    "reason": "保持層級清晰，便於維護和理解",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Folder Structure",
    "fact": "Application 層資料夾至少包含: use-cases、facades、stores、guards、mappers、tokens、services",
    "citations": "Clean Architecture: Application orchestrates use cases",
    "reason": "維持 Application 層組織清楚，便於測試與擴展",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Folder Structure",
    "fact": "Infrastructure 層資料夾至少包含: repositories、dto、converters、adapters、collections",
    "citations": "DDD: Infrastructure adapts external systems to domain contract",
    "reason": "封裝外部技術細節，保持 Domain 層純粹",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Folder Structure",
    "fact": "Presentation 層資料夾至少包含: pages、layouts、features、shared/components、shared/services",
    "citations": "Clean Architecture: Presentation only consumes Application APIs",
    "reason": "維持 UI 層統一、單向依賴 Application 層",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Folder Structure",
    "fact": "Shared 層資料夾至少包含: value-objects、enums、errors、interfaces",
    "citations": "DDD: Shared Layer provides reusable domain constructs",
    "reason": "維持跨層共享，避免循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Aggregate File Example",
    "fact": "每個 Aggregate Root 檔案 aggregate.ts 必須封裝 Entities、Value Objects，並提供行為方法，不暴露屬性 setter",
    "citations": "DDD: Aggregate Root enforces invariants",
    "reason": "保證 Aggregate 狀態一致性與業務規則完整",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Example",
    "fact": "Repository interface 檔案 repository.interface.ts 必須只依賴 Domain Entity/VO，不得回傳 DTO 或 Observable",
    "citations": "DDD: Repository is domain contract",
    "reason": "保持 Domain 純粹，不受 Infrastructure 或 Presentation 技術污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Use Case File Example",
    "fact": "Use Case 檔案 use-case.ts 必須封裝單一業務邏輯，並透過 Repository / Domain Service 執行操作，不直接操作 Infrastructure",
    "citations": "Clean Architecture: Use Case orchestrates domain",
    "reason": "維持單一責任原則和層級邊界",
    "category": "Application Layer"
  },
  {
    "subject": "Facade File Example",
    "fact": "Facade 檔案 facade.ts 必須暴露 Signals 或 Store，禁止直接操作 Repository",
    "citations": "DDD + Angular Signals: UI must not mutate domain directly",
    "reason": "維持單向資料流和 Presentation 層純粹性",
    "category": "Application Layer"
  },
  {
    "subject": "Store File Example",
    "fact": "Store 檔案 store.ts 必須管理 Signals 狀態，且只允許透過 Facade / Use Case 更新",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "維持狀態一致性與單向資料流",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Repository File Example",
    "fact": "Infrastructure repository.impl.ts 檔案必須實作對應 Domain Repository interface，封裝資料存取技術",
    "citations": "DDD: Infrastructure implements domain contracts",
    "reason": "維持 Domain 純粹與依賴倒置原則",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "DTO & Converter File Example",
    "fact": "Infrastructure dto.ts 與 converter.ts 檔案必須將外部資料結構轉換成 Domain Entity / VO",
    "citations": "Clean Architecture: DTO is infrastructure concern",
    "reason": "隔離外部資料格式，保護 Domain 純粹性",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Page File Example",
    "fact": "每個頁面必須有 page.component.ts、page.routes.ts，並配置對應 layout.component.ts（若需）",
    "citations": "Angular + Clean Architecture",
    "reason": "維持 UI 層統一，方便維護與測試",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Value Object File Example",
    "fact": "Shared value-object.ts 必須不可變、私有內部值、提供 equals 方法",
    "citations": "DDD: Value Object encapsulates equality and state",
    "reason": "跨層共享時保持一致性與安全",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Error File Example",
    "fact": "Shared error.ts 必須用於 Domain 驗證或跨層錯誤傳遞，不可依賴 Application / Infrastructure",
    "citations": "DDD + Clean Architecture",
    "reason": "保持層級隔離，防止循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Layer Folder & File Template",
    "fact": "Domain 層資料夾包含 entities、aggregates、value-objects、enums、errors、interfaces、repositories，核心檔案包括 aggregate.ts、entities.ts、value-objects.ts、repository.interface.ts、enums.ts、errors.ts",
    "citations": "DDD: Domain encapsulates business logic, Aggregate Root enforces invariants",
    "reason": "保持 Domain 純粹、完整且可追蹤",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer Dependencies",
    "fact": "Domain 層僅依賴 Shared 層的 Value Objects、Enums、Errors、Interfaces，不依賴 Application、Infrastructure 或 Presentation",
    "citations": "DDD + Clean Architecture: Domain is core layer",
    "reason": "維持單向依賴，防止污染 Domain 層",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Folder & File Template",
    "fact": "Application 層資料夾包含 use-cases、facades、stores、guards、mappers、tokens、services，核心檔案包括 use-case.ts、facade.ts、store.ts、mapper.ts、guard.ts、token.ts、service.ts",
    "citations": "Clean Architecture: Application orchestrates domain",
    "reason": "維持單一責任原則，Presentation 透過 Facade / Store 存取 Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Dependencies",
    "fact": "Application 層依賴 Domain 層的 Entities / Value Objects / Repositories Interface，以及 Shared 層，但不依賴 Infrastructure 或 Presentation",
    "citations": "Clean Architecture: Application mediates between Domain and Presentation",
    "reason": "維持層級隔離與單向依賴",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Folder & File Template",
    "fact": "Infrastructure 層資料夾包含 repositories、dto、converters、adapters、collections，核心檔案包括 repository.impl.ts、dto.ts、converter.ts、adapter.ts、collections.ts",
    "citations": "DDD: Infrastructure implements domain contracts and adapts external systems",
    "reason": "封裝技術細節，Domain 只看到 interface，不受污染",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer Dependencies",
    "fact": "Infrastructure 層依賴 Domain 層 Repository Interface / Value Objects / Entities 及 Shared 層，Presentation / Application 層不可被 Infrastructure 依賴",
    "citations": "Clean Architecture: Infrastructure adapts external systems to domain contracts",
    "reason": "保持層級依賴倒置原則",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Folder & File Template",
    "fact": "Presentation 層資料夾包含 pages、layouts、features、shared/components、shared/services，核心檔案包括 page.component.ts、page.routes.ts、layout.component.ts、shared.component.ts、shared.service.ts",
    "citations": "Clean Architecture + Angular: Presentation consumes Application APIs only",
    "reason": "維持單向資料流，UI 不污染 Domain / Application",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Dependencies",
    "fact": "Presentation 層依賴 Application 層的 Facade / Store 及 Shared 層，不直接依賴 Domain / Infrastructure",
    "citations": "Clean Architecture: UI layer interacts only via Application layer",
    "reason": "確保單向依賴與責任隔離",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Folder & File Template",
    "fact": "Shared 層資料夾包含 value-objects、enums、errors、interfaces，核心檔案包括 value-object.ts、enums.ts、errors.ts、interfaces.ts",
    "citations": "DDD: Shared Layer provides reusable constructs across layers",
    "reason": "維持跨層共享資源並避免循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Dependencies",
    "fact": "Shared 層不得依賴 Domain / Application / Infrastructure / Presentation 層，可被所有層依賴",
    "citations": "DDD + Clean Architecture",
    "reason": "確保跨層共用且不造成循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Aggregate Example File",
    "fact": "aggregate.ts 封裝 Entities / Value Objects，提供行為方法操作，禁止 public setter，確保不變條件 (invariants)",
    "citations": "DDD: Aggregate Root enforces business invariants",
    "reason": "防止外部破壞 Aggregate 狀態",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Example File",
    "fact": "repository.interface.ts 僅依賴 Domain Entity / VO，不回傳 DTO 或 Observable，定義 CRUD / 查詢方法",
    "citations": "DDD: Repository is domain contract",
    "reason": "保持 Domain 層純粹，不受技術細節污染",
    "category": "Domain Layer"
  },
  {
    "subject": "Use Case Example File",
    "fact": "use-case.ts 封裝單一業務邏輯，透過 Repository / Domain Service 執行操作，不直接操作 Infrastructure",
    "citations": "Clean Architecture: Use Case orchestrates Domain",
    "reason": "維持單一責任與層級邊界",
    "category": "Application Layer"
  },
  {
    "subject": "Facade Example File",
    "fact": "facade.ts 暴露 Signals / Store 給 Presentation，不直接操作 Repository",
    "citations": "DDD + Angular Signals: UI must not mutate Domain directly",
    "reason": "保持單向資料流，Presentation 不污染 Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Store Example File",
    "fact": "store.ts 管理 Signals 狀態，僅允許透過 Facade / Use Case 更新",
    "citations": "Angular Signals + Clean Architecture",
    "reason": "維持狀態一致性與單向資料流",
    "category": "Application Layer"
  },
  {
    "subject": "Repository Implementation Example",
    "fact": "repository.impl.ts 實作對應 Domain Repository interface，封裝資料存取技術，提供 CRUD 與查詢方法",
    "citations": "DDD: Infrastructure implements Domain contracts",
    "reason": "維持 Domain 純粹，避免 Presentation / Application 直接依賴外部系統",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "DTO & Converter Example File",
    "fact": "dto.ts 與 converter.ts 將外部資料格式轉換為 Domain Entity / VO，隔離外部資料格式",
    "citations": "Clean Architecture: DTOs are infrastructure concern",
    "reason": "保護 Domain 層純粹性與一致性",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Page Component Example File",
    "fact": "page.component.ts 與 page.routes.ts 定義頁面和路由，layout.component.ts 可選，UI 層僅透過 Facade / Store 存取 Application",
    "citations": "Angular + Clean Architecture",
    "reason": "維持 UI 層單向依賴與統一結構",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Value Object Example File",
    "fact": "value-object.ts 不可變、私有內部值、提供 equals 方法，跨層共享",
    "citations": "DDD: Value Object encapsulates equality and state",
    "reason": "確保跨層一致性與安全",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Error Example File",
    "fact": "error.ts 用於 Domain 驗證或跨層錯誤傳遞，不可依賴 Application / Infrastructure / Presentation",
    "citations": "DDD + Clean Architecture",
    "reason": "保持層級隔離，防止循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Layer Folders & Files",
    "fact": "Domain 層資料夾: entities, aggregates, value-objects, enums, errors, interfaces, repositories，每個資料夾包含對應的最小檔案，如 entities.ts、aggregate.ts、value-objects.ts、repository.interface.ts、enums.ts、errors.ts",
    "citations": "DDD: Domain encapsulates business logic and aggregates",
    "reason": "保持 Domain 層完整性與可追蹤性",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer File List",
    "fact": "entities/entities.ts, aggregates/aggregate.ts, value-objects/value-objects.ts, enums/enums.ts, errors/errors.ts, interfaces/identifiable.interface.ts, repositories/repository.interface.ts",
    "citations": "DDD standard folder structure",
    "reason": "保證 Domain 層依賴方向與功能完整",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Folders & Files",
    "fact": "Application 層資料夾: use-cases, facades, stores, guards, mappers, tokens, services，每個資料夾包含最小檔案: use-case.ts, facade.ts, store.ts, guard.ts, mapper.ts, token.ts, service.ts",
    "citations": "Clean Architecture: Application orchestrates Domain operations",
    "reason": "保持 Application 層單一責任，Presentation 透過 Facade / Store 存取 Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer File List",
    "fact": "use-cases/index.ts, facades/facade.ts, stores/store.ts, guards/guard.ts, mappers/mapper.ts, tokens/token.ts, services/service.ts",
    "citations": "Clean Architecture",
    "reason": "維持層級隔離與單向依賴",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Folders & Files",
    "fact": "Infrastructure 層資料夾: repositories, dto, converters, adapters, collections，每個資料夾包含最小檔案 repository.impl.ts, dto.ts, converter.ts, adapter.ts, collections.ts",
    "citations": "DDD: Infrastructure implements domain contracts",
    "reason": "封裝技術細節，保持 Domain 純粹",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer File List",
    "fact": "repositories/repository.impl.ts, dto/dto.ts, converters/converter.ts, adapters/adapter.ts, collections/collections.ts",
    "citations": "Clean Architecture",
    "reason": "保持 Infrastructure 與 Domain interface 對接，防止污染 Domain",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Folders & Files",
    "fact": "Presentation 層資料夾: pages, layouts, features, shared/components, shared/services，每個資料夾包含最小檔案 page.component.ts, page.routes.ts, layout.component.ts, shared.component.ts, shared.service.ts",
    "citations": "Clean Architecture + Angular Signals",
    "reason": "維持 UI 層單向依賴 Application 層",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer File List",
    "fact": "pages/page.component.ts, pages/page.routes.ts, layouts/layout.component.ts, shared/components/shared.component.ts, shared/services/shared.service.ts",
    "citations": "Angular + Clean Architecture",
    "reason": "統一 Presentation 層結構，方便維護",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Folders & Files",
    "fact": "Shared 層資料夾: value-objects, enums, errors, interfaces，每個資料夾包含最小檔案 value-object.ts, enums.ts, errors.ts, interfaces.ts",
    "citations": "DDD: Shared Layer provides reusable constructs",
    "reason": "保持跨層共享資源，避免循環依賴",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer File List",
    "fact": "value-objects/value-object.ts, enums/enums.ts, errors/errors.ts, interfaces/interfaces.ts",
    "citations": "DDD + Clean Architecture",
    "reason": "保證 Shared 層可被全層依賴但不依賴任何層",
    "category": "Shared Layer"
  }


