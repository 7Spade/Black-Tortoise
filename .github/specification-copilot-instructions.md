# GitHub Copilot 規範與最佳實踐

## 1. 核心原則

### 1.1 Domain-Driven Design (DDD) 合規性
- 嚴格遵循 DDD 原則，嚴格順序：Value Object → Entity → Aggregate → Application
- 正確定義並尊重 DDD 概念：Value Objects、Entities、Aggregates、Repositories
- 禁止「表面 DDD」- 看似遵循 DDD 但違反核心原則的實現
- 禁止任何繞過 DDD 層邊界的捷徑或繞道

### 1.2 層級邊界分離
- Domain 層必須嚴格分離：Application、Domain、Infrastructure、Interface 層
- Domain 層禁止直接使用 Router、Effects、HTTP 或其他 Infrastructure 依賴
- Application 層協調 use-cases 但不能跳過 Domain 驗證
- Infrastructure 層提供技術實現，不涉及業務邏輯
- 禁止跨層呼叫違反邊界的程式碼

### 1.3 元件職責
- 元件只能顯示狀態和觸發 use-cases
- 禁止元件執行 Domain、路由或狀態變動邏輯
- 禁止元件直接進行導航

---

## 2. 狀態管理與反應性

### 2.1 Signals-Only 方式
- 使用 Angular signals 進行反應式狀態管理
- 禁止混合 RxJS 流與 signal 狀態管理（除非明確必要）
- 禁止在核心業務邏輯中使用 Observable、Subject 或 RxJS
- 所有狀態變更必須顯式且可追蹤
- 禁止隱藏的副作用

### 2.2 狀態設計
- 初始狀態必須支援 F5 重新整理，無閃爍或意外行為
- 元件禁止直接執行狀態變動
- 必須採用三狀態驗證模式：`'unknown' | 'anonymous' | 'authenticated'`

---

## 3. 路由與驗證守衛

### 3.1 守衛實現規則
- 守衛必須基於 signals 運作，禁止非同步黑科技或 `setTimeout`
- 禁止元件驅動的導航
- 必須正確處理三個驗證狀態：
  - `unknown`：不觸發重定向（載入狀態）
  - `anonymous`：若需驗證則重定向至登入
  - `authenticated`：若適用則重定向至受保護路由

### 3.2 導航規則
- 登入元件禁止直接導航
- 所有路由決策集中在守衛中
- 禁止在元件或服務中補流程

---

## 4. 程式碼品質與反模式

### 4.1 禁止模式
- **無通用型濫用**：禁止使用 `any` 或未受限的泛型以繞過類型檢查
- **無暫時性解決方案**：禁止增加複雜度的臨時修復
- **無程式碼冗餘**：禁止功能增益不足的程式碼增加
- **無過度抽象**：禁止未來型佔位符或不必要的包裝類
- **無捷徑實現**：禁止偷工減料的任何形式

### 4.2 簡單性規則
- 簡單邏輯必須保持簡單
- 若 `if/switch` 足夠，禁止包裝成多層抽象、策略或管道
- 僅包裝現有邏輯的新類別或服務視為冗餘

### 4.3 代碼衛生
- 禁止過度抽象或未使用的佔位符
- 禁止不必要的類別、服務或包裝器
- 禁止暫時解決問題但增加複雜度的變通方案

---

## 5. 型別安全

### 5.1 嚴格型別要求
- 所有泛型必須具有明確的型別邊界
- 禁止使用 `any` 型別
- TypeScript 必須在嚴格模式下乾淨編譯
- 所有型別約束必須有意義且可強制執行

---

## 6. 輸出與實現標準

### 6.1 代碼輸出規則
- 僅輸出最小化、正確、可編譯和 AOT 相容的 TypeScript 代碼
- 所有代碼必須無 Zone.js，反應特性必須使用 signals-only
- 修改不得破壞現有功能
- 禁止建議 `npm install`、`yarn add` 或環境變更

### 6.2 構建要求
- 必須通過 TypeScript 編譯
- 必須通過 Angular AOT 構建
- 必須維持現有測試覆蓋
- 禁止重構無關程式碼

---

## 7. 技術堆棧約束

### 7.1 環境配置
- **作業系統**：Windows 11
- **套件管理器**：yarn（禁止 npm）
- **框架**：Angular 20.3.x
- **後端**：Firebase
- **UI**：Material Design 3 + Angular Material CDK
- **狀態**：ngrx/signals
- **語言**：TypeScript 5.9.x
- **資料庫**：Firestore

### 7.2 Angular 20+ 控制流語法（強制性）
- ✅ 使用 `@if` / `@else`（禁止 `*ngIf`）
- ✅ 使用 `@for`（禁止 `*ngFor`）
- ✅ 使用 `@switch` / `@case`（禁止 `*ngSwitch`）
- ✅ 使用 `@defer` 進行延遲載入
- ❌ **禁止所有舊版結構型指令**（`*ngIf`、`*ngFor`、`*ngSwitch`）

---

## 8. 專案結構

### 8.1 資料夾組織
- 必須明確分離：Domain / Application / Infrastructure / Interfaces / Shared
- 禁止違反邊界的跨層呼叫
- 每層必須有明確定義的職責

---

## 9. 子代理推理與令牌最佳化

### 9.1 效率要求
- 使用子代理推理進行分析、規劃和實現
- 僅輸出最終可行代碼
- 禁止代碼輸出中的中間推理或評論
- 在產生完整實現的同時最小化令牌使用

---

## 10. 驗證與檢查清單

接受任何 Copilot 建議前，驗證：

1. ✅ 無捷徑或偷工減料的實現
2. ✅ 無泛型型別濫用危害型別安全
3. ✅ 無 DDD 層邊界違反
4. ✅ 無簡單邏輯的過度複雜化
5. ✅ 無冗餘/無效的類別、服務或函式
6. ✅ 守衛和驗證流正確處理 F5 重新整理
7. ✅ 核心邏輯中無 RxJS 與 signals 混合
8. ✅ 無元件驅動的導航或路由

---

## 11. 記憶與持續改進

### 11.1 學習要求
- 內化這些規則並在整個儲存庫中一致應用
- 任何違反都是嚴重錯誤，需要立即更正
- 未來建議必須通過此規範作為硬約束進行篩選
- 維護合規歷史以防止重複違反

---

## 總結

此規範的目的：
- 統一 Copilot 行為
- 防止破壞性實現
- 維持長期可維護性
- 強制執行嚴格的 DDD 合規性
- 確保 Angular 20+ 最佳實踐
- 在技術債務形成前消除

**任何違反這些規則的行為必須立即更正。**